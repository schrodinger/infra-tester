{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Testing Infrastructure as Code (IaC) can be very complex. Usually, you pick one of the several testing frameworks or libraries available in your programming language of choice such as Go or Python. The vast majority of the infrastructure (unit) tests mostly make sure:</p> <ul> <li>A module deploys without any failure for valid inputs.</li> <li>Guard rails work as expected in catching invalid inputs or states.</li> <li>The outputs of a module are as expected.</li> </ul> <p>With infra-tester, these could be achieved without writing tests in a programming language such as Go or Python. You can define the tests using YAML configuration. This reduces the barrier in testing infrastructure by not having to worry about maintaining lots of code just for testing. infra-tester provides several assertions that you can use and we'll add even more as more people use it.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Terraform must be already installed on your system and available in <code>$PATH</code> as infra-tester does not bundle Terraform. See official Terraform documentation on how to install it.</p>"},{"location":"#install-infra-tester","title":"Install infra-tester","text":"<p>Install</p> Install using GoInstall from GitHub Release - Linux and MacOSInstall from GitHub Release - WindowsBuild From Source <pre><code>go install github.com/schrodinger/infra-tester@latest\n</code></pre> <pre><code>PLATFORM=linux\nPLATFORM=macos\n# Download the latest release binary\n$ curl -L https://github.com/schrodinger/infra-tester/releases/latest/download/infra-tester-${PLATFORM}-x86_64 -o infra-tester\n\n# Make it executable\n$ chmod +x infra-tester\n\n# Move it to a directory in the $PATH\n$ sudo mv infra-tester /usr/local/bin\n</code></pre> <ol> <li> <p>Download the latest Windows release binary from the below URL:     <pre><code>https://github.com/schrodinger/infra-tester/releases/latest/download/infra-tester-windows-x86_64.exe\n</code></pre></p> </li> <li> <p>Move it to a directory under <code>PATH</code>, or add the directory where you'd like to keep the executable to <code>PATH</code>.</p> </li> </ol> <pre><code># Clone the repo\n$ git clone git@github.com:schrodinger/infra-tester.git\n\n# Build the executable and move the binary to a directory in the $PATH\n$ cd infra-tester &amp;&amp; go build -o bin/infra-tester\n$ sudo mv infra-tester /usr/local/bin\n\n# OR you may run go install\n$ go install\n</code></pre>"},{"location":"#writing-your-first-infra-tester-test-configuration","title":"Writing Your First infra-tester Test Configuration","text":"<p>The Writing a Test From Scratch page provides a simple hands-on tutorial where we write a simple Terraform module and then write a test config to test it.</p>"},{"location":"#use-infra-tester-to-run-tests","title":"Use infra-tester to run tests","text":"<p>Once infra-tester is set up, run the example tests:</p> <p>Running Example Tests</p> <pre><code># Clone the repo\n$ git clone git@github.com:schrodinger/infra-tester.git\n\n# Change directory to example tests\n$ cd example/\n\n# Install plugin example assertions to run test\n$ pip install \\\n    \"git+https://github.com/schrodinger/infra-tester.git#subdirectory=python-plugins/\" \\\n     \"git+https://github.com/schrodinger/infra-tester.git#subdirectory=example/plugin-example/\"\n\n# Run the tests\n$ infra-tester -test.v\n</code></pre>"},{"location":"#extending-infra-tester-using-plugins","title":"Extending infra-tester Using Plugins","text":"<p>If you are interested in extending infra-tester's assertion library by writing plugins, we provide extensive documentation on how developers can write plugins in Python and then use them in the test configuration.</p>"},{"location":"apply_assertions/","title":"Apply Assertions","text":"<p>Apply assertions will be run after running <code>terraform apply</code>.</p>"},{"location":"apply_assertions/#applysucceeds","title":"ApplySucceeds","text":"<p>Asserts that <code>terraform apply</code> succeeds.</p> SchemaExample <pre><code>- name: &lt;name&gt;\n  type: ApplySucceeds\n</code></pre> <pre><code>- name: ApplyShouldSucceed\n  type: ApplySucceeds\n</code></pre> Inputs Description Type Required <code>name</code> Name for the assertion String No"},{"location":"apply_assertions/#outputequal","title":"OutputEqual","text":"<p>Compares a specified terraform output with an expected value.</p> SchemaExample 1Example 2Example 3Example 4Example 5 <pre><code>- name: &lt;name&gt;\n  type: OutputEqual\n  output_name: &lt;output_name&gt;\n  value: &lt;value&gt;\n</code></pre> <pre><code># `value` is of string type\n- name: ASimpleOutputEqualExample\n  type: OutputEqual\n  output_name: sample_output\n  value: a sample value\n\n# `value` is of boolean type\n- name: OutputEqualExampleForBool\n  type: OutputEqual\n  output_name: a_boolean_output\n  value: true\n\n# `value` is of float type\n- name: OutputEqualExampleForFloat\n  type: OutputEqual\n  output_name: a_float_output\n  value: 123.11\n</code></pre> <pre><code># `value` is of map type\n- name: OutputEqualExampleForMap\n  type: OutputEqual\n  output_name: a_map_output\n  value:\n    key: value\n</code></pre> <pre><code># `value` is of sequence type\n- name: OutputEqualExampleForList\n  type: OutputEqual\n  output_name: a_list_output\n  value:\n    - a\n    - b\n    - c\n</code></pre> <pre><code># `value` is of an object type.\n# Note this example does not have `complete_match` enabled and\n# so it only checks the terraform output for keys and their values\n# for the specified fields (In this case, it checks values of \"seq\",\n# \"map\", \"nested_map\", \"nested_key\", and \"boolean\" and ignores other\n# fields).\n- name: OutputEqualExampleForComplexOutput\n  type: OutputEqual\n  output_name: a_complex_output\n  value:\n    seq:\n      - a\n      - b\n      - c\n    map:\n      key: value\n      nested_map:\n        nested_key: nested_value\n    boolean: true\n</code></pre> <pre><code># `value` is of an object type, and a complete match is done\n- name: OutputEqualExampleForComplexOutputWithCompleteMatch\n  type: OutputEqual\n  output_name: a_complex_output\n  complete_match: true      # Complete match is set to true\n  value:\n    natural_number: 100\n    float: 123.11\n    seq:\n      - a\n      - b\n      - c\n    str: hello\n    map:\n      key: value\n      nested_map:\n        nested_key: nested_value\n    boolean: true\n</code></pre> Inputs Description Type Required <code>name</code> Name for the assertion String No <code>output_name</code> Terraform output name to compare String Yes <code>value</code> The expected value - value can be of complex data type including objects consisting of maps, sequences, booleans, floats, integers, etc String, Integer, Float, Boolean, Map, Sequence, Object Yes <code>complete_match</code> Whether to match the full output by making sure the terraform output value has exactly the same fields specified in <code>value</code> - false by default Boolean No"},{"location":"apply_assertions/#outputsareequal","title":"OutputsAreEqual","text":"<p>Compares multiple terraform outputs and asserts that all the specified outputs have the same value.</p> SchemaExample 1Example 2 <pre><code>- name: &lt;name&gt;\n  type: OutputsAreEqual\n  output_names:\n    - &lt;output_name_1&gt;\n    - &lt;output_name_2&gt;\n    ...\n</code></pre> <pre><code>- name: TwoOutputsMustMatch\n  type: OutputsAreEqual\n  output_names:\n    - sample_output\n    - another_output\n</code></pre> <pre><code>- name: MultipleOutputsMustMatch\n  type: OutputsAreEqual\n  output_names:\n    - sample_output\n    - another_output\n    - yet_another_output\n</code></pre> Inputs Description Type Required <code>name</code> Name for the assertion String No <code>output_names</code> List of terraform output names Sequence of String Yes"},{"location":"apply_assertions/#outputcontains","title":"OutputContains","text":"<p>Asserts that the specified terraform output contains a specified string.</p> SchemaExample <pre><code>- name: &lt;name&gt;\n  type: OutputContains\n  output_name: &lt;output_name&gt;\n  value: &lt;value&gt;\n</code></pre> <pre><code>- name: OutputContainsACertainSubString\n  type: OutputContains\n  output_name: sample_output\n  value: a certain substring\n</code></pre> Inputs Description Type Required <code>name</code> Name for the assertion String No <code>output_name</code> Name of the terraform output String Yes <code>value</code> A substring that the terraform output must contain String Yes"},{"location":"apply_assertions/#outputmatchesregex","title":"OutputMatchesRegex","text":"<p>Asserts that the specified terraform output matches a specified regular expression.</p> SchemaExample <pre><code>- name: &lt;name&gt;\n  type: OutputMatchesRegex\n  output_name: &lt;output_name&gt;\n  regex: &lt;value&gt;\n</code></pre> <pre><code>- name: OutputShouldMatchARegularExpression\n  type: OutputMatchesRegex\n  output_name: a_fourth_output\n  regex: strings \\w+ \\d+ apple \\d\\s+\\w+\n</code></pre> Inputs Description Type Required <code>name</code> Name for the assertion String No <code>output_name</code> Name of the terraform output String Yes <code>regex</code> Regular expression that the terraform output should match against String Yes"},{"location":"apply_assertions/#resourcesaffected","title":"ResourcesAffected","text":"<p>Asserts that <code>terraform apply</code> added, and/or changed, and/or destroyed a specified number of resources.</p> SchemaExample 1Example 2 <pre><code>- name: &lt;name&gt;\n  type: ResourcesAffected\n  added: &lt;added&gt;\n  changed: &lt;changed&gt;\n  destroyed: &lt;destroyed&gt;\n</code></pre> <pre><code># This only asserts that 1 resource has been added.\n- name: MustAddExactlyOneResource\n  type: ResourcesAffected\n  added: 1\n\n# This only asserts that 5 resources have been changed.\n- name: MustChangeFiveResource\n  type: ResourcesAffected\n  changed: 5\n\n# This only asserts that 1 resource has been destroyed.\n- name: MustDestroyOneResource\n  type: ResourcesAffected\n  destroyed: 1\n</code></pre> <pre><code># This only asserts that 1 resource has been added, and 5 were changed.\n- name: MustAffectSpecificNumberOfResources\n  type: ResourcesAffected\n  added: 1\n  changed: 5\n\n# This only asserts that 1 resource has been added, 5 were changed, and 0 were destroyed.\n- name: MustAffectSpecificNumberOfResources\n  type: ResourcesAffected\n  added: 1\n  changed: 5\n  destroyed: 0\n</code></pre> Inputs Description Type Required <code>name</code> Name for the assertion String No <code>added</code> Number of resources that must have been added Integer No <code>changed</code> Number of resources that must have been changed Integer No <code>destroyed</code> Number of resources that must have been destroyed Integer No <p>Warning</p> <p>At least one of <code>added</code>, <code>changed</code>, or <code>destroyed</code> must be specified. If a field is not specified, infra-tester will not check against that specific field. Note that the default for unspecified fields is not zero.</p>"},{"location":"apply_assertions/#noresourcesaffected","title":"NoResourcesAffected","text":"<p>Similar to ResourcesAffected, but asserts that no resources have been added, changed, or destroyed.</p> SchemaExample <pre><code>- name: &lt;name&gt;\n  type: NoResourcesAffected\n</code></pre> <pre><code>- name: MustAffectNoResource\n  type: NoResourcesAffected\n</code></pre>"},{"location":"assertions/","title":"Assertions","text":"<p>Assertions are the core of infra-tester. infra-tester provides several assertions to define your tests. \"Plan assertions\" run after the <code>terraform plan</code> step and \"Apply Assertions\" run after the <code>terraform apply</code> step.</p> <p>Assertions generally have the following schema:</p> <pre><code>- name: &lt;An optional name for the assertion&gt;\n  type: &lt;Type of the assertion&gt;\n  &lt;Inputs specific to the assertion&gt;\n</code></pre>"},{"location":"assertions/#name","title":"<code>name</code>","text":"<p>This an optional field which allows you to set a custom meaningful name for the assertion. If a value is set for <code>name</code>, it will be used in generating the test summary.</p>"},{"location":"assertions/#type","title":"<code>type</code>","text":"<p>The value of <code>type</code> must be one of the valid assertion types available. You can refer to plan and apply assertions for the list of valid assertions.</p>"},{"location":"assertions/#assertion-inputs","title":"Assertion Inputs","text":"<p>Some assertions may require inputs, and different assertions will have different inputs.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>infra-tester uses YAML as its configuration language and supports most of YAML 1.1 and 1.2, including support for anchors, tags, map merging, etc. When infra-tester is run, it looks for a <code>.infra-tester-config.yaml</code> file in the current directory to run the tests.</p> <p>The configuration for infra-tester has the following structure:</p> <pre><code>test_plan:\n  name: &lt;Name of the test plan, usually the resource or module name&gt;\n\n  # Optional field, if defined passes vars defined\n  # here to the final cleanup destroy.\n  destroy_vars:\n    # By default, infra-tester passes vars in the last test to terraform\n    # destroy. If the last test has invalid vars, this field will be useful\n    # to pass valid vars to successfully run destroy.\n    ...\n\n  # A list of tests to be run.\n  tests:\n    # Each test must have a unique name.\n    - name: &lt;Name of the test&gt;\n\n      # Whether this test should be run in a clean state. If true, terraform\n      # destroy will be run before running the test. Default is false.\n      with_clean_state: false\n\n      # Any values to be passed as vars to terraform.\n      # Support complex objects as well.\n      vars:\n        complex_object: &amp;complex_object\n          id: 0\n          count: 0\n          str: \"string\"\n          seq:\n            - one\n            - two\n          map:\n            key: value\n\n      # Any checks that are to be run during the plan step.\n      plan:\n        # You can check for as many assertions as you want.\n        assertions:\n          - type: &lt;AssertionType&gt;           # The type of assertion\n            &lt;Assertion Inputs&gt;              # Any inputs to the assertions\n\n          # Example\n          - type: PlanSucceeds\n\n      # Any assertions that are to be run during the apply step.\n      apply:\n        # If true, makes sure the apply is idempotent.\n        ensure_idempotent: true\n        assertions:                         # list of assertions\n          - type: &lt;AssertionType&gt;           # The type of assertion\n            &lt;Assertion Inputs&gt;              # Any inputs to the assertions\n\n          # Example\n          - type: OutputEqual               # An example assertion\n            output_name: sample_output\n            value: it's working\n</code></pre>"},{"location":"configuration/#test_plan","title":"<code>test_plan</code>","text":"<p>infra-tester looks for the <code>test_plan</code> key to figure out what tests to run. All other top-level keys are not considered a part of the test configuration. This means you can have custom YAML blocks at the top level that can be referred to within the <code>test_plan</code>. This will be particularly useful if you'd like to keep the config DRY by reusing commonly used blocks or values.</p>"},{"location":"configuration/#test_planname","title":"<code>test_plan.name</code>","text":"<p>The test plan must define a <code>name</code>. This will be used in the test summary. It's recommended to name the tests as the resource or the module you are testing.</p>"},{"location":"configuration/#test_plandestroy_vars","title":"<code>test_plan.destroy_vars</code>","text":"<p>You can optionally set the value of <code>destroy_vars</code> to the value that must be used for the final cleanup at the end of all tests. This will be useful when the last test in the config may be set to fail intentionally due to invalid values for the input variables. Since infra-tester uses the last used vars to perform the final cleanup, invalid inputs may cause the final cleanup to fail, and so setting <code>destroy_vars</code> allows you to pass values specifically for the final cleanup.</p>"},{"location":"configuration/#test_plantests","title":"<code>test_plan.tests</code>","text":"<p>The <code>test_plan.tests</code> key should contain a list of tests that will be run for the given test plan.</p>"},{"location":"configuration/#test_plantestsname","title":"<code>test_plan.tests.name</code>","text":"<p>Each test must have a unique name across a given test plan. These names will be used in tests summary generation.</p>"},{"location":"configuration/#test_plantestswith_clean_state","title":"<code>test_plan.tests.with_clean_state</code>","text":"<p>infra-tester run terraform apply between each test to move from one test to another. Running destroy between each and every test is possible, but more often than not, the tests within a test plan have lots of similarity and running destroy and then apply to recreate essentially the same state with a slight difference is generally not efficient. There are use cases which require tests to be run in a clean state. For this reason infra-tester runs apply between tests but still provides an option to run a test with a clean state if that is absolutely required. This can be done by setting the value of <code>with_clean_state</code> to <code>true</code>.</p>"},{"location":"configuration/#test_plantestsvars","title":"<code>test_plan.tests.vars</code>","text":"<p><code>test_plan.tests.vars</code> can be used to pass values for the terraform input variables for running <code>terraform plan</code> and <code>terraform apply</code>. All data types are supported, and infra-tester will convert the values in YAML to appropriate terraform data types.</p>"},{"location":"configuration/#test_plantestsplan","title":"<code>test_plan.tests.plan</code>","text":"<p>This contains the list of assertions that will be run after running <code>terraform plan</code> with the <code>test.vars</code> as input. Assertions can be defined under the key <code>assertions</code>. Read more about assertions here.</p>"},{"location":"configuration/#test_plantestsapply","title":"<code>test_plan.tests.apply</code>","text":"<p>This contains the list of assertions that will be run after running <code>terraform apply</code> with the <code>test.vars</code> as input. Assertions can be defined under the key <code>assertions</code>. Read more about assertions here.</p> <p>If the tests require terraform apply to be idempotent, you can set <code>ensure_idempotent</code> to <code>true</code> to make sure the apply does not result in any more changes when run a second time after the first apply.</p>"},{"location":"configuration/#test_plantestsplanapplyassertions","title":"<code>test_plan.tests.(plan|apply).assertions</code>","text":"<p>This key contains a list of assertions to be in the <code>plan</code> or <code>apply</code> step respectively. Each assertion should specify the <code>type</code> key. It can optionally define a name, which if provided will be used in the test summary generation, else it uses the <code>type</code> value.</p>"},{"location":"configuration/#validation","title":"Validation","text":"<p>infra-tester will validate the configuration before running any tests. Each assertion will have its own validation that checks for required fields, the type of the value, whether regular expression is valid and so on. This provides a better experience when writing a test configuration and minimizes the time lost chasing trivial bugs in the configuration.</p>"},{"location":"extending_infra_tester/","title":"Writing Plugins","text":"<p>Even though infra-tester provides several inbuilt assertions for tests, there will always be a case where you'll have to test something that might not be possible with just the inbuilt set of assertions.</p> <p>Since infrastructure varies a lot this is bound to happen, and a good way to tackle this is through plugins.</p> <p>infra-tester provides a plugin system where you can create your custom assertions in Python and then consume them through YAML configuration. This way, plugin owners can create assertions that can then be shared or published so that others who may not be proficient in Python could use them by installing the plugin.</p> <p>Let's see how the plugin system works.</p>"},{"location":"extending_infra_tester/#plugin-design","title":"Plugin Design","text":"<p>infra-tester chose Python 3.8 and above as the plugin language for the following reasons:</p> <ul> <li>Python is a relatively simple language</li> <li>Has an extensive standard library that could assist in implementing plugins</li> <li>Entry Point Spec which makes it an ideal ecosystem to write plugins</li> <li>The PIP package manager makes it easy to package and install plugins   through the official PIP registry, a custom registry, or through a version   control system or even install the plugin from a local file system</li> </ul> <p>The below sequence diagram shows how infra-tester interacts with the plugins:</p> <pre><code>\nsequenceDiagram\n    infra-tester-&gt;&gt;plugin-host: Fetch available plugins\n    plugin-host--&gt;&gt;infra-tester: &lt;List of available plugins&gt;\n\n    infra-tester-&gt;&gt;plugin-host: Run plugin validation\n    plugin-host-&gt;&gt;plugin: Calls `validate_assertion` function of the plugin\n    plugin--&gt;&gt;plugin-host: Returns validation error message if any\n    plugin-host--&gt;&gt;infra-tester: Returns validation result\n\n    infra-tester-&gt;&gt;plugin-host: Run plugin assertion\n    plugin-host-&gt;&gt;plugin: Calls `run_assertion` function of the plugin\n    plugin--&gt;&gt;plugin-host: Returns error message if any\n    plugin-host--&gt;&gt;infra-tester: Returns assertion result\n\n    infra-tester-&gt;&gt;plugin-host: Run plugin cleanup\n    plugin-host-&gt;&gt;plugin: Calls `cleanup` function of the plugin\n    plugin--&gt;&gt;plugin-host: Returns error message if any\n    plugin-host--&gt;&gt;infra-tester: Returns cleanup result</code></pre> <p>In the above diagram:</p> <ul> <li>plugin-host is a PIP package, which if installed enables plugin support   for infra-tester.</li> <li>plugin is a PIP package that can be used by infra-tester as a plugin.</li> </ul> <p>infra-tester uses the plugin-host to communicate with the plugin.</p> <p>As a plugin implementor, you only have to be concerned about the plugin package.</p>"},{"location":"extending_infra_tester/#plugin-host","title":"Plugin Host","text":"<p>You can install the plugin host by installing the <code>infra-tester-plugins</code> PIP package.</p> <p>Info</p> <p>As of now, you can install the plugin host through PIP using the following command: <pre><code>pip install \"git+https://github.com/schrodinger/infra-tester.git#subdirectory=python-plugins/\"\n</code></pre></p> <p>We are currently looking into adding this package to the official PIP registry.</p> <p>Once the package is installed, infra-tester will automatically enable plugin support.</p>"},{"location":"extending_infra_tester/#plugins","title":"Plugins","text":""},{"location":"extending_infra_tester/#requirements","title":"Requirements","text":"<p>Before starting, ensure that <code>infra-tester-plugins</code> package is installed. This provides the <code>BaseAssertionPlugin</code> class, which needs to be inherited to implement the plugin.</p> <p>As a best practice, it's recommended to follow a standard directory structure when creating the Python package. Generally, it's recommended to follow the below directory structure:</p> <pre><code>.\n\u2514\u2500\u2500 &lt;package-directory-name&gt;/\n    \u251c\u2500\u2500 src/\n    \u2502   \u251c\u2500\u2500 &lt;module1&gt;/\n    \u2502   \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u2502   \u2514\u2500\u2500 ...\n    \u2502   \u2514\u2500\u2500 &lt;module2&gt;/\n    \u2502       \u251c\u2500\u2500 __init__.py\n    \u2502       \u2514\u2500\u2500 ...\n    \u251c\u2500\u2500 pyproject.toml\n    \u2514\u2500\u2500 setup.py\n</code></pre>"},{"location":"extending_infra_tester/#the-baseassertionplugin-class","title":"The <code>BaseAssertionPlugin</code> Class","text":"<p>infra-tester provides the <code>BaseAssertionPlugin</code> base class which can be used to implement the core of the plugin logic.</p> <pre><code>from infra_tester_plugins import BaseAssertionPlugin\n\nclass CustomAssertionPlugin(BaseAssertionPlugin):\n    def validate_inputs(self, inputs: dict): ...\n\n    def run_assertion(self, inputs: dict, state: dict): ...\n\n    def cleanup(self, inputs: dict, state: dict): ... # optional\n\n\ndef load_plugin() # A function that'll be referenced in pyproject.toml.\n    # This function must return an instance of the assertion implementation.\n\n    return CustomAssertionPlugin()\n</code></pre>"},{"location":"extending_infra_tester/#def-validate_inputsself-inputs-dict-unionstr-none","title":"<code>def validate_inputs(self, inputs: dict) -&gt; Union[str, None]</code>:","text":"<p>Validate the inputs provided to the plugin. The inputs will be in the form of a dictionary with the key being the name of the input and the value being the value of the input.</p> <p>This method should return <code>None</code> if the inputs are valid. Otherwise, it should return a string describing the error.</p> <p>Any exception thrown by this method will be treated as an implementation error and will be logged as such.</p> ArgumentsExceptionsReturn Value Name Description Type <code>inputs</code> Python dictionary containing the inputs provided to the assertion Dictionary Exception Description <code>NotImplementedError</code> If the plugin does not implement this method. Type Description <code>Union[str, None]</code> If the inputs are valid, return <code>None</code>. Otherwise, return a string describing the error."},{"location":"extending_infra_tester/#def-run_assertionself-inputs-dict-state-dict-unionstr-none","title":"<code>def run_assertion(self, inputs: dict, state: dict) -&gt; Union[str, None]</code>:","text":"<p>This method should contain the logic to run the assertion and return the result.</p> <p>If the assertion fails, this method should return a string describing the error. Otherwise, it should return <code>None</code>.</p> <p>This method should not raise any exception. Any exception thrown by this method will be treated as an implementation error and will be logged as such.</p> ArgumentsExceptionsReturn Value Name Description Type <code>inputs</code> Python dictionary containing the inputs provided to the assertion Dictionary <code>state</code> Python dictionary containing the Terraform state information Dictionary Exception Description <code>NotImplementedError</code> If the plugin does not implement this method. Type Description <code>Union[str, None]</code> <code>None</code> if the assertion passes. Otherwise return a string describing why the assertion failed."},{"location":"extending_infra_tester/#def-cleanupself-inputs-dict-state-dict-none","title":"<code>def cleanup(self, inputs: dict, state: dict) -&gt; None</code>:","text":"<p>Cleanup any resources used by the plugin. This method will be called after the plugin has been run regardless of whether the run was successful or not. It is optional and does not need to be implemented if there's nothing to clean up.</p> <p>If this method is implemented, it should be idempotent, i.e, cleanup should always have the same end result regardless of how many times it is called. Cleanup is considered successful if it does not raise any exception.</p> Arguments Name Description Type <code>inputs</code> Python dictionary containing the inputs provided to the assertion Dictionary <code>state</code> Python dictionary containing the Terraform state information Dictionary"},{"location":"extending_infra_tester/#pyprojecttoml-and-setuppy","title":"<code>pyproject.toml</code> and <code>setup.py</code>","text":"<p>The plugin packages need to provide <code>pyproject.toml</code> and <code>setup.py</code> files for the following reasons:</p> <ul> <li>Make the plugin installable through PIP package manager.</li> <li>Register the package as an infra-tester plugin.</li> </ul> <p>See project.toml documentation to create a <code>pyproject.toml</code> file for your plugin.</p> <p>Apart from this, one important part of creating <code>pyproject.toml</code> file is to register the package as a plugin by adding it to the <code>infra-tester.assertion</code> entry points group. This can be done by defining a <code>[project.entry-points.\"infra_tester.assertion\"]</code> section in the <code>pyproject.toml</code> file, like so:</p> pyproject.tomlExample <pre><code>[project.entry-points.\"infra_tester.assertion\"]\n&lt;UniqueAssertionName1&gt; = \"&lt;package_or_module1&gt;:load_plugin\"\n&lt;UniqueAssertionName1&gt; = \"&lt;package_or_module1&gt;:load_plugin\"\n...\n</code></pre> <pre><code>[project.entry-points.\"infra_tester.assertion\"]\nExampleAssertion = \"example:load_plugin\"\nURLReachable = \"url_reachable:load_plugin\"\n</code></pre> <p>Info</p> <p>A single python package can register multiple plugins (assertions). This makes it easy to create for example an \"infra-tester-network-assertion\" which provides several different network assertions as plugins.</p> <p>It's strongly recommended to create a <code>setup.py</code> for the project as well to support older PIP versions too. You can use a shim in <code>setup.py</code> to not have duplicated configuration like so:</p> setup.py<pre><code>import setuptools\n\nif __name__ == \"__main__\":\n    setuptools.setup()\n</code></pre>"},{"location":"extending_infra_tester/#example-plugin-package","title":"Example Plugin Package","text":"<p>This section shows an example package that provides two plugins:</p> <ul> <li>\"ExampleAssertion\" that just prints the inputs and state in the test logs.</li> <li>\"URLReachable\" that checks whether a URL is reachable.</li> </ul> ExampleAssertionURLReachablepyproject.tomlUsage in .infra-tester-config.yamlPackage Directory Structure example/plugin-example/src/example/__init__.py<pre><code>from typing import Dict\n\nfrom infra_tester_plugins import BaseAssertionPlugin\n\n\nclass ExampleAssertionPlugin(BaseAssertionPlugin):\n    def validate_inputs(self, inputs: Dict[str, object]):\n        print(\"Running validate_inputs from ExampleAssertionPlugin\")\n        print(\"Inputs:\", inputs)\n\n        if (\n            \"should_fail_validation\" in inputs\n            and inputs[\"should_fail_validation\"]\n        ):\n            return \"This is a validation error message.\"\n\n        return None\n\n    def run_assertion(\n        self, inputs: Dict[str, object], state: Dict[str, object]\n    ):\n        print(\"Running run_assertion from ExampleAssertionPlugin\")\n        print(\"Inputs:\", inputs)\n        print(\"State:\", state)\n\n        if (\n            \"should_error\" in inputs\n            and inputs[\"should_error\"]\n        ):\n            message = \"This is an assertion error message.\"\n            if \"custom_message\" in state and state[\"custom_message\"]:\n                message += f\" Plus here's a custom message: \\\n                            {state['custom_message']}\"\n\n            return message\n\n        return None\n\n    def cleanup(self, inputs: Dict[str, object], state: Dict[str, object]):\n        print(\"Running cleanup from ExampleAssertionPlugin\")\n        print(\"Inputs:\", inputs)\n        print(\"State:\", state)\n\n\ndef load_plugin():\n    return ExampleAssertionPlugin()\n</code></pre> example/plugin-example/src/url_reachable/__init__.py<pre><code>from typing import Dict\nfrom urllib import error, request\nfrom urllib.parse import urlparse\n\nfrom infra_tester_plugins import BaseAssertionPlugin\n\n\nclass URLReachableAssertionPlugin(BaseAssertionPlugin):\n    FIELD_URL = \"url\"\n    FIELD_STATUS_CODE = \"status_code\"\n    FIELD_FROM_OUTPUTS = \"from_outputs\"\n\n    @classmethod\n    def validate_url(cls, plugin_inputs: Dict[str, object]):\n        if cls.FIELD_URL not in plugin_inputs:\n            return \"url is a required input.\"\n\n        if cls.FIELD_FROM_OUTPUTS in plugin_inputs:\n            from_outputs = plugin_inputs[cls.FIELD_FROM_OUTPUTS]\n\n            if not isinstance(from_outputs, bool):\n                return \"from_outputs must be a boolean.\"\n\n            if from_outputs:\n                return None\n\n        url = plugin_inputs[cls.FIELD_URL]\n\n        if not isinstance(url, str):\n            return \"url must be a string.\"\n\n        try:\n            parse_res = urlparse(url)\n\n            if not parse_res.scheme:\n                return \"url must have a scheme.\"\n\n            if not parse_res.netloc:\n                return \"url must have a valid network location.\"\n        except ValueError:\n            return \"url must be a valid.\"\n\n        return None\n\n    @classmethod\n    def validate_status_code(cls, plugin_inputs: Dict[str, object]):\n        # status_code is optional\n        if cls.FIELD_STATUS_CODE not in plugin_inputs:\n            return None\n\n        status_code = plugin_inputs[cls.FIELD_STATUS_CODE]\n\n        if not isinstance(status_code, int):\n            return \"status_code must be an integer.\"\n\n        # Not being strict about the status code range here.\n        if status_code &lt; 0:\n            return (\n                f\"status_code must be valid. \"\n                f\"Received {status_code} of type {type(status_code)}.\"\n            )\n\n        return None\n\n    def validate_inputs(self, inputs: Dict[str, object]):\n        print(\"Running validate_inputs for URLReachable\")\n\n        url_validation = self.validate_url(inputs)\n        if url_validation:\n            return url_validation\n\n        status_code_validation = self.validate_status_code(inputs)\n        if status_code_validation:\n            return status_code_validation\n\n        return None\n\n    def assert_url_reachable(self, url: str, expected_status_code: int):\n        try:\n            res = request.urlopen(url)\n\n            if res.getcode() != expected_status_code:\n                return (\n                    f\"Unexpected status code for {url}: {res.getcode()}. \"\n                    f\"Expected {expected_status_code}.\"\n                )\n        except error.HTTPError as e:\n            if e.code == expected_status_code:\n                return None\n\n            return (\n                f\"Unexpected status code for {url}: {e.code}. \"\n                f\"Expected {expected_status_code}.\"\n            )\n        except error.URLError as e:\n            return f\"Failed to reach {url}: {e.reason}.\"\n        except Exception as e:\n            return f\"Failed to reach {url}: {e}\"\n\n        return None\n\n    def get_url_from_outputs(self, output_name: str, state: Dict[str, object]):\n        if \"values\" not in state or \"outputs\" not in state[\"values\"]:\n            raise ValueError(\n                (\n                    \"Could not find 'values' in state. \"\n                    \"Make sure terraform apply has been \"\n                    \"run successfully.\"\n                )\n            )\n\n        outputs = state[\"values\"][\"outputs\"]\n        if output_name not in outputs:\n            raise ValueError(\n                (\n                    f\"Could not find {output_name} in outputs. \"\n                    \"Make sure your terraform code has an \"\n                    f\"output named {output_name}.\"\n                )\n            )\n\n        return outputs[output_name][\"value\"]\n\n    def run_assertion(\n        self, inputs: Dict[str, object], state: Dict[str, object]\n    ):\n        print(\"Running run_assertion for URLReachable\")\n\n        plugin_inputs = inputs\n        url = plugin_inputs[self.FIELD_URL]\n        from_outputs = plugin_inputs.get(self.FIELD_FROM_OUTPUTS, False)\n\n        if from_outputs:\n            url = self.get_url_from_outputs(url, state)\n\n        expected_status_code = inputs.get(\n            self.FIELD_STATUS_CODE, 200\n        )\n\n        return self.assert_url_reachable(url, expected_status_code)\n\n\ndef load_plugin():\n    return URLReachableAssertionPlugin()\n</code></pre> <p>This registers both the \"ExampleAssertion\" and \"URLReachable\" assertions</p> example/plugin-example/pyproject.toml<pre><code>[project]\nname = \"infra-tester-example-plugin\"\nversion = \"0.1.0\"\n\n[project.entry-points.\"infra_tester.assertion\"]\nExampleAssertion = \"example:load_plugin\"\nURLReachable = \"url_reachable:load_plugin\"\n</code></pre> example/.infra-tester-config.yaml<pre><code>...\n  - name: ExamplesCustomAssertions\n    apply:\n        assertions:\n        - name: ThisOneAlwaysSucceeds\n          type: ExampleAssertion\n\n        - name: URLShouldBeReachable\n          type: URLReachable\n          url: https://www.schrodinger.com\n\n        - name: URLRedirectsAreFollowedToReachableURL\n          type: URLReachable\n          url: http://www.schrodinger.com\n          status_code: 200\n\n        - name: OutputURLShouldBeReachable\n          type: URLReachable\n          url: sample_url\n          from_outputs: true\n\n        - name: URLShouldNotBeReachable\n          type: URLReachable\n          url: https://google.com/doesnotexist\n          status_code: 404\n...\n</code></pre> <pre><code>. # example/ folder in the infra-tester git repo\n\u2514\u2500\u2500 plugin-example\n    \u251c\u2500\u2500 pyproject.toml\n    \u251c\u2500\u2500 setup.py\n    \u2514\u2500\u2500 src\n        \u251c\u2500\u2500 example\n        \u2502   \u2514\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 url_reachable\n            \u2514\u2500\u2500 __init__.py\n</code></pre> <p>You can install the above package by running <code>pip install -e &lt;path/to/package&gt;</code>.</p>"},{"location":"extending_infra_tester/#testing-your-plugin","title":"Testing Your Plugin","text":"<p>You may use the <code>infra-tester-run-plugin</code> command to execute your plugin independently to test its working. We also recommend writing unit tests for your plugins to catch any issues early on.</p> <p>Run <code>infra-tester-run-plugin -h</code> to see how to use this CLI command.</p>"},{"location":"extending_infra_tester/#listing-available-plugins","title":"Listing Available Plugins","text":"<p>You can list the available packages using the <code>infra-tester-plugin-manager</code> CLI command provided by the <code>infra-tester-plugins</code> package.</p> <pre><code>$ infra-tester-plugin-manager --list\nExampleAssertion\nURLReachable\n</code></pre>"},{"location":"extending_infra_tester/#conclusion","title":"Conclusion","text":"<p>The plugin system provides a mechanism in which developers can write plugins in Python and then publish them so that other people who may not be familiar with Python or programming in general could still write tests in a simple YAML config.</p> <p>As with all plugin systems which allows running external code, make sure you trust the plugin by auditing its code to ensure that unwanted code is not executed in your environment.</p> <p>If you feel a plugin might be a better fit as an inbuilt assertion, please reach out by raising an issue in our GitHub repository.</p>"},{"location":"infra_tester_internals/","title":"How infra-tester Works Internally","text":"<p>infra-tester uses terratest internally to run Terraform tests. Once infra-tester parses the test configuration, for each test:</p> <ol> <li>If at least one plan assertion is found, it'll run <code>terraform plan</code> with the input variables if defined.</li> <li>It then runs all the assertions under the plan step.</li> <li>If any of the plan step assertions fails, it skips the apply assertions for the test. This can be considered a \"fail fast\" mechanism      to prevent unnecessary cost and time wastage when the plan tests have failed.</li> <li>If all the plan assertions were successful, it then proceeds to apply assertions.</li> <li>infra-tester runs <code>terraform plan</code> with the input variables if defined. Note that a destroy won't be called before running the      apply unless <code>with_clean_state</code> is set to true. This is for efficiency reasons, see <code>test_plan.tests.with_clean_state</code>.</li> <li>Once all the tests are run, infra-tester proceeds to destroy all resources as a final cleanup procedure.</li> </ol> <pre><code>%%{init: {'theme':'neutral'}}%%\n\nflowchart TB\n  subgraph TestPlan[&lt;b&gt;Test Plan&lt;/b&gt;]\n    direction TB\n    subgraph Test1[&lt;b&gt;Test 1&lt;/b&gt;]\n        direction LR\n        Plan1(Plan\\nResource\\nCreation) --&gt; AssertP1(Plan\\nAssertions\\n1..N&lt;sub&gt;1&lt;/sub&gt;) --&gt; Create1(Resource\\nCreation) --&gt; Assert1(Assertions\\n1..M&lt;sub&gt;1&lt;/sub&gt;)\n    end\n    subgraph Test2[&lt;b&gt;Test 2&lt;/b&gt;]\n        direction LR\n        Plan2(Plan\\nResource\\nModification) --&gt; AssertP2(Plan\\nAssertions\\n1..N&lt;sub&gt;2&lt;/sub&gt;) --&gt; Create2(Resource\\nModification) --&gt; Assert2(Assertions\\n1..M&lt;sub&gt;2&lt;/sub&gt;)\n    end\n    subgraph TestN[&lt;b&gt;Test N&lt;/b&gt;]\n        direction LR\n        PlanN(Plan\\nResource\\nModification) --&gt; AssertPN(Plan\\nAssertions\\n1..N&lt;sub&gt;k&lt;/sub&gt;) --&gt; CreateN(Resource\\nModification) --&gt; AssertN(Assertions\\n1..M&lt;sub&gt;k&lt;/sub&gt;)\n    end\n    Test1 --&gt; Test2\n    Test2 --&gt; dots((...))\n    dots((...)) --&gt; TestN\n  end\nStart:::term --&gt; Test1\nTestN --&gt; destroy(Destroy\\nResources) --&gt; End:::term</code></pre>"},{"location":"plan_assertions/","title":"Plan Assertions","text":"<p>Plan assertions will be run after running <code>terraform plan</code>.</p>"},{"location":"plan_assertions/#plansucceeds","title":"PlanSucceeds","text":"<p>Asserts that <code>terraform plan</code> succeeds.</p> SchemaExample <pre><code>- name: &lt;name&gt;\n  type: PlanSucceeds\n</code></pre> <pre><code>- name: PlanShouldSucceed\n  type: PlanSucceeds\n</code></pre> Inputs Description Type Required <code>name</code> Name for the assertion String No"},{"location":"plan_assertions/#planfails","title":"PlanFails","text":"<p>Asserts that <code>terraform plan</code> fails.</p> SchemaExample <pre><code>- name: &lt;name&gt;\n  type: PlanFails\n</code></pre> <pre><code>- name: PlanMustFail\n  type: PlanFails\n</code></pre> Inputs Description Type Required <code>name</code> Name for the assertion String No"},{"location":"plan_assertions/#planfailswitherror","title":"PlanFailsWithError","text":"<p>Asserts that <code>terraform plan</code> with an error containing a certain substring.</p> SchemaExample <pre><code>- name: &lt;name&gt;\n  type: PlanFailsWithError\n  error_message_contains: &lt;error_message_contains&gt;\n</code></pre> <pre><code>- name: MustFailWithSampleError\n  type: PlanFailsWithError\n  error_message_contains: Failed with sample error\n</code></pre> Inputs Description Type Required <code>name</code> Name for the assertion String No <code>error_message_contains</code> String that should be present in the error message String Yes"},{"location":"test_output/","title":"Test Output","text":"<p>A test summary is generated at the end of the test if infra-tester is run with the <code>-test.v</code> flag.</p> Test Summary<pre><code>-- PASS: Tests (4.39s)\n    --- PASS: Tests/&lt;TestPlanName&gt; (4.39s)\n        --- PASS: Tests/&lt;TestPlanName&gt;/&lt;TestName&gt; (0.25s)\n            --- PASS: Tests/&lt;TestPlanName&gt;/&lt;TestName&gt;/Plan (0.25s)\n                --- PASS: Tests/&lt;TestPlanName&gt;/&lt;TestName&gt;/Plan/&lt;PlanAssertion1&gt; (0.00s)\n                --- PASS: Tests/&lt;TestPlanName&gt;/&lt;TestName&gt;/Plan/&lt;PlanAssertion2&gt; (0.00s)\n                    ...\n            --- PASS: Tests/&lt;TestPlanName&gt;/&lt;TestName&gt;/Apply (0.25s)\n                --- PASS: Tests/&lt;TestPlanName&gt;/&lt;TestName&gt;/Apply/&lt;ApplyAssertion1&gt; (0.00s)\n                --- PASS: Tests/&lt;TestPlanName&gt;/&lt;TestName&gt;/Apply/&lt;ApplyAssertion2&gt; (0.00s)\n                    ...\nPASS\n</code></pre> <p>In the above test summary:</p> <ul> <li><code>TestPlanName</code> is obtained from the <code>name</code> property of <code>test_plan</code> in the YAML config.</li> <li><code>TestName</code> corresponds to the <code>name</code> of each test defined in the test plan.</li> <li><code>PlanAssertion1</code>, <code>PlanAssertion2</code>, and so on refer to the name (if defined, else assertion type) of the assertions in the plan step.</li> <li><code>ApplyAssertion1</code>, <code>ApplyAssertion2</code>, and so on refer to the name (if defined, else assertion type) of the assertions in the apply step.</li> </ul> <p>As seen in the test summary, Plan and Apply tests are separated so you can run them separately using <code>-test.run</code> flag.</p> <p>Warning</p> <p>If a test is dependent (e.g, by using a test as a \"stage\") on the resultant Terraform state of a previous test, then selectively running a test that has such a dependency will obviously fail. In this case, you might want to name the test and its dependency test in such a way that, when you selectively run the test with a test name pattern, both the tests will be selected.</p>"},{"location":"writing_tests/","title":"Writing a Test From Scratch","text":"<p>In this section, we'll write a simple Terraform code to create some local resources. We'll then write a configuration to run tests using infra-tester.</p> <p>Before proceeding any further, make sure Terraform and infra-tester are installed in your environment. Refer to Install infra-tester section on how to install it.</p>"},{"location":"writing_tests/#terraform","title":"Terraform","text":"<p>Since we'd like this example to be simple and easy to follow, we'll use the <code>time</code> provider to create a time \"resource\" and then we'll see how we can test it.</p> <p>Let's start by creating a Terraform file and then adding the terraform block with version constraints and required providers.</p> test.tf<pre><code>terraform {\n  required_version = \"&gt;= 0.12\"\n  required_providers {\n    time = {\n      source  = \"hashicorp/time\"\n      version = \"&gt;= 0.8\"\n    }\n  }\n}\n</code></pre> <p>Now let's define a basic <code>time_static</code> resource and then add its value to the outputs.</p> test.tf<pre><code># Create a time resource.\nresource \"time_static\" \"my_time\" {}\n\n# Show the current time in the RFC-3339 format.\noutput \"current_time\" {\n  value = time_static.my_time.rfc3339\n}\n</code></pre> <p>And that's it for the Terraform code. Let's try it out. <pre><code>terraform init\nterraform apply # Review your plan and approve the changes.\n# You should see the `current_time` output. You can also run\nterraform show # to see the outputs.\nterraform destroy # To destroy the resources.\n</code></pre></p>"},{"location":"writing_tests/#writing-tests-using-infra-tester","title":"Writing Tests Using infra-tester","text":"<p>Let's imagine that we use this Terraform code or module to generate a time stamp which is then consumed by other modules. Maybe the other modules expect the output to be in a certain format. In this case, we'd like to ensure that the output adheres to the RFC 3339 format no matter what underlying provider we use to generate the <code>current_time</code> output.</p> <p>A basic test would be a regular expression matching to make sure the output adheres to the RFC 3339 format. Let's see how we can write such a test using infra-tester.</p> <p>Let's create a <code>.infra-tester-config.yaml</code> file in the same directory where we created the Terraform file and copy the below code into it. See the annotation next to the code to understand what it does.</p> .infra-tester-config.yaml<pre><code>test_plan:\n  name: Time #(1)\n  tests: # (2)\n    - name: CurrentTimeOutputTests # (3)\n      apply: # (4)\n        assertions: # (5)\n          - name: TimeStringMatchesRFC3339 # (6)\n            type: OutputMatchesRegex # (7)\n            output_name: current_time # (8)\n            regex: ^((?:(\\d{4}-\\d{2}-\\d{2})T(\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?))(Z|[\\+-]\\d{2}:\\d{2})?)$ # (9)\n</code></pre> <ol> <li>This is the test plan name. All the tests are grouped under this test plan name. It's best to name it the same as the module or component name.</li> <li>The <code>tests</code> block can contain a list of tests that are to be run.</li> <li>Each test must have a unique name. This name will show up in the final test output.</li> <li>The <code>apply</code> block can contain assertions that will be run after <code>terraform apply</code> was run. Similarly, there's also a <code>plan</code> block which can also contain a list of assertions that are to be run after a <code>terraform plan</code>.</li> <li>The <code>assertions</code> block can contain a list of assertions to be run under the <code>plan</code> or <code>apply</code> step depending on whether it's defined under <code>plan</code> or <code>apply</code> block.</li> <li>An assertion can optionally have a name. If a name is not provided the <code>type</code> of assertion will be used to generate a name for the assertion in the test output.</li> <li><code>type</code> of assertion determines what assertion will be run. This must be a valid assertion. infra-tester provides several inbuilt assertion types. It also supports a plugin system to introduce custom assertions as well.</li> <li><code>output_name</code> is an input field specific to the <code>OutputMatchesRegex</code> assertion. The assertion captures the string value of the output named <code>output_name</code> to match the regular expression.</li> <li><code>OutputMatchesRegex</code> specific input field which will be used to match against the output value.</li> </ol> <p>The above configuration is all that's required to test the use case we mentioned before. Now let's run the tests using infra-tester.</p>"},{"location":"writing_tests/#running-the-tests","title":"Running the Tests","text":"<p>Change the working directory to the same directory where you created the Terraform file and the <code>.infra-tester-config.yaml</code> file and run</p> <pre><code>infra-tester -test.v\n</code></pre> <p>The <code>-test.v</code> flag can be used to run tests in verbose mode.</p> <p>You should see the logs appear as the test runs, and finally, the test output is printed.</p> <pre><code>--- PASS: Tests (3.35s)\n    --- PASS: Tests/Time (2.97s)\n        --- PASS: Tests/Time/CurrentTimeOutputTests (1.03s)\n            --- PASS: Tests/Time/CurrentTimeOutputTests/Apply (1.03s)\n                --- PASS: Tests/Time/CurrentTimeOutputTests/Apply/TimeStringMatchesRFC3339 (0.09s)\nPASS\n</code></pre>"},{"location":"writing_tests/#try-breaking-it","title":"Try Breaking It!","text":"<p>Let's modify the regular expression so that it's invalid and see what happens.</p> <p>To make it invalid let's remove the first two opening brackets, so the line would then be:</p> .infra-tester-config.yaml<pre><code>            regex: ^?:(\\d{4}-\\d{2}-\\d{2})T(\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?))(Z|[\\+-]\\d{2}:\\d{2})?)$\n</code></pre> <p>Let's run <code>infra-tester -test.v</code> to see what happens.</p> <p><pre><code>$ infra-tester -test.v\n=== RUN   Tests\n    assertions.go:117: ERROR: Failure during test validation: test 'CurrentTimeOutputTests' failed validation: assertion 'OutputMatchesRegex' for apply step failed validation because - invalid regular expression\n--- FAIL: Tests (0.36s)\nFAIL\n</code></pre> As you can see, infra-tester runs test validation before running any of the tests, and in this specific case, it caught the invalid regular expression.</p> <p>Catching issues early on is very important, especially in the case of Infrastructure as Code, as it reduces the time wasted on silly typos and easy-to-catch issues. This leads to a better developer experience.</p> <p>Let us now try to pass it a valid regular expression but one that doesn't adhere to RFC 3339. Let's modify the line to the following:</p> .infra-tester-config.yaml<pre><code>            regex: ^((?:T(\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?))(Z|[\\+-]\\d{2}:\\d{2})?)$\n</code></pre> <p>And now if you run infra-tester again, the validation passes, but the test fails as expected:</p> <pre><code>--- FAIL: Tests (1.60s)\n    --- FAIL: Tests/Time (1.27s)\n        --- FAIL: Tests/Time/CurrentTimeOutputTests (0.47s)\n            --- FAIL: Tests/Time/CurrentTimeOutputTests/Apply (0.47s)\n                --- FAIL: Tests/Time/CurrentTimeOutputTests/Apply/TimeStringMatchesRFC3339 (0.08s)\nFAIL\n</code></pre>"},{"location":"writing_tests/#whats-more","title":"What's More?","text":"<p>This section covered the basics of infra-tester. There are several more features like passing variable inputs through the YAML configuration, partially matching complex Terraform outputs, creating custom assertions to extend infra-tester's capabilities and so on, all of which are extensively documented in this documentation site.</p>"}]}